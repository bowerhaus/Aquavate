/**
 * Aquavate - Display State Tracking Module
 * Centralized display logic with smart update detection
 */

#include "display.h"
#include "config.h"
#include "drinks.h"
#include "calibration.h"
#include "aquavate.h"
#include <sys/time.h>
#include <time.h>

// External dependencies from main.cpp
extern Adafruit_NAU7802 nau;
extern bool nauReady;
extern CalibrationData g_calibration;
extern bool g_calibrated;
extern int8_t g_timezone_offset;
extern bool g_time_valid;

// External battery functions (defined in main.cpp for Adafruit Feather)
#if defined(BOARD_ADAFRUIT_FEATHER)
extern float getBatteryVoltage();
extern int getBatteryPercent(float voltage);
#endif

// Display state (internal to this module)
static DisplayState g_display_state;
static ThinkInk_213_Mono_GDEY0213B74* g_display_ptr = nullptr;

// Bitmap data (moved from main.cpp)
// Water drop icon bitmap (60x60 pixels)
const unsigned char water_drop_bitmap[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0xFF, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0xFF, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x03, 0xFF, 0x80, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x03, 0xFF, 0x80, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x07, 0xFF, 0xC0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x07, 0xFF, 0xC0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x0F, 0xFF, 0xE0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x0F, 0xFF, 0xE0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x1F, 0xFF, 0xF0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x1F, 0xFF, 0xF0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7F, 0xFF, 0xFC, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7F, 0xFF, 0xFC, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00,
    0x00, 0x01, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
    0x00, 0x01, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
    0x00, 0x03, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00,
    0x00, 0x03, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00,
    0x00, 0x07, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00,
    0x00, 0x07, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00,
    0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00,
    0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00,
    0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00,
    0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00,
    0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00,
    0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00,
    0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00,
    0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00,
    0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00,
    0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00,
    0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00,
    0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00,
    0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00,
    0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00,
    0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00,
    0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00,
    0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00,
    0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00,
    0x00, 0x07, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00,
    0x00, 0x07, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00,
    0x00, 0x03, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00,
    0x00, 0x03, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00,
    0x00, 0x01, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
    0x00, 0x01, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7F, 0xFF, 0xFC, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x1F, 0xFF, 0xF0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x0F, 0xFF, 0xE0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x07, 0xFF, 0xC0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0xFF, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x00
};

#define WATER_DROP_WIDTH 60
#define WATER_DROP_HEIGHT 60

// Human figure bitmap (50x83 pixels)
const unsigned char PROGMEM human_figure_bitmap[] = {
    0x00, 0x00, 0x03, 0xB0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x0E, 0xFC, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3A, 0x0F, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x50, 0x03, 0x80, 0x00, 0x00,
    0x00, 0x00, 0xE0, 0x00, 0xC0, 0x00, 0x00,
    0x00, 0x00, 0x80, 0x00, 0xC0, 0x00, 0x00,
    0x00, 0x01, 0xC0, 0x00, 0x60, 0x00, 0x00,
    0x00, 0x01, 0x00, 0x00, 0x60, 0x00, 0x00,
    0x00, 0x03, 0x80, 0x00, 0x30, 0x00, 0x00,
    0x00, 0x01, 0x00, 0x00, 0x30, 0x00, 0x00,
    0x00, 0x03, 0x00, 0x00, 0x20, 0x00, 0x00,
    0x00, 0x03, 0x00, 0x00, 0x30, 0x00, 0x00,
    0x00, 0x01, 0x00, 0x00, 0x30, 0x00, 0x00,
    0x00, 0x03, 0x00, 0x00, 0x30, 0x00, 0x00,
    0x00, 0x01, 0x80, 0x00, 0x60, 0x00, 0x00,
    0x00, 0x01, 0x80, 0x00, 0x60, 0x00, 0x00,
    0x00, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0x00,
    0x00, 0x00, 0xC0, 0x01, 0x40, 0x00, 0x00,
    0x00, 0x00, 0x70, 0x03, 0x80, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x0D, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x17, 0xFE, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x06, 0xD0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x91, 0x20, 0x00, 0x00,
    0x00, 0x07, 0xFF, 0xFF, 0xFA, 0x00, 0x00,
    0x00, 0x1E, 0xFD, 0x55, 0x5E, 0x00, 0x00,
    0x00, 0x70, 0x00, 0x00, 0x05, 0x80, 0x00,
    0x00, 0xD0, 0x00, 0x00, 0x01, 0xC0, 0x00,
    0x00, 0xC0, 0x00, 0x00, 0x00, 0xE0, 0x00,
    0x01, 0x80, 0x00, 0x00, 0x00, 0x50, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00,
    0x07, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
    0x04, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00,
    0x06, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00,
    0x0C, 0x06, 0x00, 0x00, 0x18, 0x0C, 0x00,
    0x04, 0x06, 0x00, 0x00, 0x18, 0x0C, 0x00,
    0x0C, 0x06, 0x00, 0x00, 0x18, 0x0C, 0x00,
    0x0C, 0x0D, 0x00, 0x00, 0x1C, 0x04, 0x00,
    0x18, 0x0E, 0x00, 0x00, 0x14, 0x0E, 0x00,
    0x18, 0x1A, 0x00, 0x00, 0x1E, 0x04, 0x00,
    0x10, 0x16, 0x00, 0x00, 0x1A, 0x07, 0x00,
    0x18, 0x1E, 0x00, 0x00, 0x17, 0x02, 0x00,
    0x30, 0x36, 0x00, 0x00, 0x1D, 0x03, 0x00,
    0x30, 0x34, 0x00, 0x00, 0x13, 0x03, 0x00,
    0x20, 0x66, 0x00, 0x00, 0x1B, 0x81, 0x80,
    0x70, 0x66, 0x00, 0x00, 0x19, 0x03, 0x00,
    0x40, 0x66, 0x00, 0x00, 0x09, 0xC1, 0x80,
    0x60, 0xC4, 0x00, 0x00, 0x18, 0x80, 0x80,
    0x60, 0xC6, 0x00, 0x00, 0x18, 0xE1, 0xC0,
    0xC1, 0x86, 0x00, 0x00, 0x08, 0x40, 0x80,
    0x41, 0x86, 0x00, 0x00, 0x1C, 0x60, 0xC0,
    0xE2, 0x86, 0x00, 0x00, 0x08, 0x71, 0x80,
    0x5B, 0x0A, 0x00, 0x00, 0x18, 0x2D, 0x80,
    0x3E, 0x06, 0x00, 0x00, 0x0C, 0x1F, 0x00,
    0x00, 0x06, 0x00, 0x00, 0x18, 0x04, 0x00,
    0x00, 0x0C, 0x00, 0xC0, 0x08, 0x00, 0x00,
    0x00, 0x06, 0x00, 0xC0, 0x1C, 0x00, 0x00,
    0x00, 0x04, 0x00, 0xC0, 0x08, 0x00, 0x00,
    0x00, 0x0E, 0x01, 0xA0, 0x0C, 0x00, 0x00,
    0x00, 0x04, 0x00, 0xE0, 0x18, 0x00, 0x00,
    0x00, 0x0E, 0x01, 0xA0, 0x0C, 0x00, 0x00,
    0x00, 0x04, 0x01, 0xE0, 0x08, 0x00, 0x00,
    0x00, 0x0C, 0x01, 0x60, 0x1C, 0x00, 0x00,
    0x00, 0x06, 0x03, 0x30, 0x08, 0x00, 0x00,
    0x00, 0x0C, 0x01, 0xB0, 0x0C, 0x00, 0x00,
    0x00, 0x04, 0x03, 0x20, 0x18, 0x00, 0x00,
    0x00, 0x0E, 0x03, 0x30, 0x0C, 0x00, 0x00,
    0x00, 0x04, 0x02, 0x18, 0x08, 0x00, 0x00,
    0x00, 0x0C, 0x07, 0x18, 0x0C, 0x00, 0x00,
    0x00, 0x06, 0x04, 0x18, 0x0C, 0x00, 0x00,
    0x00, 0x0C, 0x06, 0x18, 0x0C, 0x00, 0x00,
    0x00, 0x0C, 0x06, 0x08, 0x0C, 0x00, 0x00,
    0x00, 0x04, 0x0A, 0x1C, 0x0C, 0x00, 0x00,
    0x00, 0x0C, 0x04, 0x08, 0x0C, 0x00, 0x00,
    0x00, 0x0C, 0x0C, 0x0C, 0x08, 0x00, 0x00,
    0x00, 0x04, 0x0C, 0x0C, 0x0C, 0x00, 0x00,
    0x00, 0x0C, 0x0C, 0x06, 0x0C, 0x00, 0x00,
    0x00, 0x06, 0x18, 0x0C, 0x18, 0x00, 0x00,
    0x00, 0x07, 0x68, 0x07, 0x58, 0x00, 0x00,
    0x00, 0x03, 0xB0, 0x03, 0xF0, 0x00, 0x00,
    0x00, 0x00, 0xC0, 0x00, 0xA0, 0x00, 0x00,
};

#define HUMAN_FIGURE_WIDTH 50
#define HUMAN_FIGURE_HEIGHT 83

// Human figure FILLED bitmap (50x83 pixels) - flood filled
const unsigned char PROGMEM human_figure_filled_bitmap[] = {
    0x00, 0x00, 0x03, 0xB0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x0F, 0xFC, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3F, 0xFF, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x5F, 0xFF, 0x80, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0xFF, 0xC0, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0xFF, 0xC0, 0x00, 0x00,
    0x00, 0x01, 0xFF, 0xFF, 0xE0, 0x00, 0x00,
    0x00, 0x01, 0xFF, 0xFF, 0xE0, 0x00, 0x00,
    0x00, 0x03, 0xFF, 0xFF, 0xF0, 0x00, 0x00,
    0x00, 0x01, 0xFF, 0xFF, 0xF0, 0x00, 0x00,
    0x00, 0x03, 0xFF, 0xFF, 0xE0, 0x00, 0x00,
    0x00, 0x03, 0xFF, 0xFF, 0xF0, 0x00, 0x00,
    0x00, 0x01, 0xFF, 0xFF, 0xF0, 0x00, 0x00,
    0x00, 0x03, 0xFF, 0xFF, 0xF0, 0x00, 0x00,
    0x00, 0x01, 0xFF, 0xFF, 0xE0, 0x00, 0x00,
    0x00, 0x01, 0xFF, 0xFF, 0xE0, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0xFF, 0xC0, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0xFF, 0x40, 0x00, 0x00,
    0x00, 0x00, 0x7F, 0xFF, 0x80, 0x00, 0x00,
    0x00, 0x00, 0x3F, 0xFD, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x17, 0xFE, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x06, 0xD0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x91, 0x20, 0x00, 0x00,
    0x00, 0x07, 0xFF, 0xFF, 0xFA, 0x00, 0x00,
    0x00, 0x1F, 0xFF, 0xFF, 0xFE, 0x00, 0x00,
    0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00,
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x00,
    0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xD0, 0x00,
    0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00,
    0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00,
    0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00,
    0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00,
    0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00,
    0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00,
    0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x00,
    0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x00,
    0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x00,
    0x0F, 0xFD, 0xFF, 0xFF, 0xFF, 0xFC, 0x00,
    0x1F, 0xFF, 0xFF, 0xFF, 0xF7, 0xFE, 0x00,
    0x1F, 0xFB, 0xFF, 0xFF, 0xFF, 0xFC, 0x00,
    0x1F, 0xF7, 0xFF, 0xFF, 0xFB, 0xFF, 0x00,
    0x1F, 0xFF, 0xFF, 0xFF, 0xF7, 0xFE, 0x00,
    0x3F, 0xF7, 0xFF, 0xFF, 0xFD, 0xFF, 0x00,
    0x3F, 0xF7, 0xFF, 0xFF, 0xF3, 0xFF, 0x00,
    0x3F, 0xE7, 0xFF, 0xFF, 0xFB, 0xFF, 0x80,
    0x7F, 0xE7, 0xFF, 0xFF, 0xF9, 0xFF, 0x00,
    0x7F, 0xE7, 0xFF, 0xFF, 0xF9, 0xFF, 0x80,
    0x7F, 0xC7, 0xFF, 0xFF, 0xF8, 0xFF, 0x80,
    0x7F, 0xC7, 0xFF, 0xFF, 0xF8, 0xFF, 0xC0,
    0xFF, 0x87, 0xFF, 0xFF, 0xF8, 0x7F, 0x80,
    0x7F, 0x87, 0xFF, 0xFF, 0xFC, 0x7F, 0xC0,
    0xFE, 0x87, 0xFF, 0xFF, 0xF8, 0x7F, 0x80,
    0x5F, 0x0B, 0xFF, 0xFF, 0xF8, 0x2F, 0x80,
    0x3E, 0x07, 0xFF, 0xFF, 0xFC, 0x1F, 0x00,
    0x00, 0x07, 0xFF, 0xFF, 0xF8, 0x04, 0x00,
    0x00, 0x0F, 0xFF, 0xFF, 0xF8, 0x00, 0x00,
    0x00, 0x07, 0xFF, 0xFF, 0xFC, 0x00, 0x00,
    0x00, 0x07, 0xFF, 0xFF, 0xF8, 0x00, 0x00,
    0x00, 0x0F, 0xFF, 0xBF, 0xFC, 0x00, 0x00,
    0x00, 0x07, 0xFF, 0xFF, 0xF8, 0x00, 0x00,
    0x00, 0x0F, 0xFF, 0xBF, 0xFC, 0x00, 0x00,
    0x00, 0x07, 0xFF, 0xFF, 0xF8, 0x00, 0x00,
    0x00, 0x0F, 0xFF, 0x7F, 0xFC, 0x00, 0x00,
    0x00, 0x07, 0xFF, 0x3F, 0xF8, 0x00, 0x00,
    0x00, 0x0F, 0xFF, 0xBF, 0xFC, 0x00, 0x00,
    0x00, 0x07, 0xFF, 0x3F, 0xF8, 0x00, 0x00,
    0x00, 0x0F, 0xFF, 0x3F, 0xFC, 0x00, 0x00,
    0x00, 0x07, 0xFE, 0x1F, 0xF8, 0x00, 0x00,
    0x00, 0x0F, 0xFF, 0x1F, 0xFC, 0x00, 0x00,
    0x00, 0x07, 0xFC, 0x1F, 0xFC, 0x00, 0x00,
    0x00, 0x0F, 0xFE, 0x1F, 0xFC, 0x00, 0x00,
    0x00, 0x0F, 0xFE, 0x0F, 0xFC, 0x00, 0x00,
    0x00, 0x07, 0xFA, 0x1F, 0xFC, 0x00, 0x00,
    0x00, 0x0F, 0xFC, 0x0F, 0xFC, 0x00, 0x00,
    0x00, 0x0F, 0xFC, 0x0F, 0xF8, 0x00, 0x00,
    0x00, 0x07, 0xFC, 0x0F, 0xFC, 0x00, 0x00,
    0x00, 0x0F, 0xFC, 0x07, 0xFC, 0x00, 0x00,
    0x00, 0x07, 0xF8, 0x0F, 0xF8, 0x00, 0x00,
    0x00, 0x07, 0xE8, 0x07, 0xF8, 0x00, 0x00,
    0x00, 0x03, 0xB0, 0x03, 0xF0, 0x00, 0x00,
    0x00, 0x00, 0xC0, 0x00, 0xA0, 0x00, 0x00,
};

// Helper: Quantize battery percentage to 20% steps
static uint8_t quantizeBatteryPercent(int raw_percent) {
    if (raw_percent >= 90) return 100;
    if (raw_percent >= 70) return 80;
    if (raw_percent >= 50) return 60;
    if (raw_percent >= 30) return 40;
    if (raw_percent >= 10) return 20;
    return 0;
}

// Helper: Get day name from weekday number (0=Sunday, 1=Monday, etc.)
static const char* getDayName(int weekday) {
    switch (weekday) {
        case 0: return "Sun";
        case 1: return "Mon";
        case 2: return "Tue";
        case 3: return "Wed";
        case 4: return "Thu";
        case 5: return "Fri";
        case 6: return "Sat";
        default: return "---";
    }
}

// Helper: Format time for display as "Wed 2pm" (day + 12-hour format)
static void formatTimeForDisplay(char* buffer, size_t buffer_size) {
    if (!g_time_valid) {
        snprintf(buffer, buffer_size, "--- --");
        return;
    }

    struct timeval tv;
    gettimeofday(&tv, NULL);
    time_t now = tv.tv_sec + (g_timezone_offset * 3600);
    struct tm timeinfo;
    gmtime_r(&now, &timeinfo);

    const char* day = getDayName(timeinfo.tm_wday);
    int hour_12 = timeinfo.tm_hour % 12;
    if (hour_12 == 0) hour_12 = 12;
    const char* am_pm = (timeinfo.tm_hour < 12) ? "am" : "pm";

    snprintf(buffer, buffer_size, "%s %d%s", day, hour_12, am_pm);
}

#if defined(BOARD_ADAFRUIT_FEATHER)
// Helper: Draw battery icon
static void drawBatteryIcon(int x, int y, int percent) {
    g_display_ptr->drawRect(x, y, 20, 12, EPD_BLACK);
    g_display_ptr->fillRect(x + 20, y + 3, 3, 6, EPD_BLACK);
    int fillWidth = (percent * 16) / 100;
    if (fillWidth > 0) {
        g_display_ptr->fillRect(x + 2, y + 2, fillWidth, 8, EPD_BLACK);
    }
}

// Helper: Draw bottle graphic
static void drawBottleGraphic(int x, int y, float fill_percent) {
    int bottle_width = 40;
    int bottle_height = 90;
    int bottle_body_height = 70;
    int neck_height = 10;
    int cap_height = 10;

    int fill_height = (int)(bottle_body_height * fill_percent);

    g_display_ptr->fillRoundRect(x, y + cap_height + neck_height,
                                 bottle_width, bottle_body_height, 8, EPD_BLACK);
    g_display_ptr->fillRoundRect(x + 2, y + cap_height + neck_height + 2,
                                 bottle_width - 4, bottle_body_height - 4, 6, EPD_WHITE);

    int neck_width = bottle_width - 12;
    int neck_x = x + 6;
    g_display_ptr->fillRect(neck_x, y + cap_height, neck_width, neck_height, EPD_BLACK);
    g_display_ptr->fillRect(neck_x + 2, y + cap_height + 2, neck_width - 4, neck_height - 4, EPD_WHITE);

    int cap_width = neck_width - 4;
    int cap_x = neck_x + 2;
    g_display_ptr->fillRect(cap_x, y, cap_width, cap_height, EPD_BLACK);

    if (fill_height > 0) {
        int water_y = y + cap_height + neck_height + bottle_body_height - fill_height;
        g_display_ptr->fillRoundRect(x + 4, water_y,
                                     bottle_width - 8, fill_height - 2, 4, EPD_BLACK);
    }
}

// Helper: Draw human figure with progressive fill
static void drawHumanFigure(int x, int y, float fill_percent) {
    int fill_start_row = (int)(HUMAN_FIGURE_HEIGHT * (1.0f - fill_percent));
    int bytes_per_row = (HUMAN_FIGURE_WIDTH + 7) / 8;

    for (int row = 0; row < HUMAN_FIGURE_HEIGHT; row++) {
        int byte_offset = row * bytes_per_row;
        const unsigned char* bitmap_to_use = (row >= fill_start_row) ?
            human_figure_filled_bitmap : human_figure_bitmap;

        for (int col = 0; col < HUMAN_FIGURE_WIDTH; col++) {
            int byte_index = byte_offset + (col / 8);
            int bit_index = 7 - (col % 8);
            uint8_t byte_val = pgm_read_byte(&bitmap_to_use[byte_index]);
            bool pixel_set = (byte_val & (1 << bit_index)) != 0;

            if (pixel_set) {
                g_display_ptr->drawPixel(x + col, y + row, EPD_BLACK);
            }
        }
    }
}

// Helper: Draw tumbler grid
static void drawGlassGrid(int x, int y, float fill_percent) {
    const int GLASS_WIDTH = 18;
    const int GLASS_HEIGHT = 16;
    const int GLASS_SPACING_X = 4;
    const int GLASS_SPACING_Y = 2;
    const int COLS = 2;
    const int ROWS = 5;
    const int TOTAL_GLASSES = COLS * ROWS;

    float total_fill = fill_percent * TOTAL_GLASSES;
    if (total_fill > TOTAL_GLASSES) total_fill = TOTAL_GLASSES;

    int glass_index = 0;

    for (int row = ROWS - 1; row >= 0; row--) {
        for (int col = 0; col < COLS; col++) {
            int glass_x = x + col * (GLASS_WIDTH + GLASS_SPACING_X);
            int glass_y = y + row * (GLASS_HEIGHT + GLASS_SPACING_Y);

            float glass_fill = 0.0f;
            if (total_fill >= glass_index + 1) {
                glass_fill = 1.0f;
            } else if (total_fill > glass_index) {
                glass_fill = total_fill - glass_index;
            }

            g_display_ptr->drawLine(glass_x, glass_y, glass_x + 3, glass_y + GLASS_HEIGHT - 1, EPD_BLACK);
            g_display_ptr->drawLine(glass_x + GLASS_WIDTH - 1, glass_y, glass_x + GLASS_WIDTH - 4, glass_y + GLASS_HEIGHT - 1, EPD_BLACK);
            g_display_ptr->drawLine(glass_x, glass_y, glass_x + GLASS_WIDTH - 1, glass_y, EPD_BLACK);
            g_display_ptr->drawLine(glass_x + 3, glass_y + GLASS_HEIGHT - 1, glass_x + GLASS_WIDTH - 4, glass_y + GLASS_HEIGHT - 1, EPD_BLACK);

            if (glass_fill > 0.0f) {
                int fill_height = (int)((GLASS_HEIGHT - 2) * glass_fill);
                int fill_start_row = GLASS_HEIGHT - 1 - fill_height;

                for (int i = fill_start_row; i < GLASS_HEIGHT - 1; i++) {
                    float ratio = (float)i / (float)(GLASS_HEIGHT - 1);
                    int top_inset = 1;
                    int bottom_inset = 4;
                    int current_inset = top_inset + (int)(ratio * (bottom_inset - top_inset));

                    int line_start = glass_x + current_inset;
                    int line_end = glass_x + GLASS_WIDTH - 1 - current_inset;
                    g_display_ptr->drawLine(line_start, glass_y + i, line_end, glass_y + i, EPD_BLACK);
                }
            }

            glass_index++;
        }
    }
}
#endif

// Public API Implementation

void displayInit(ThinkInk_213_Mono_GDEY0213B74& display_ref) {
    g_display_ptr = &display_ref;
    g_display_state.initialized = false;
    g_display_state.water_ml = -1.0f;
    g_display_state.daily_total_ml = 0;
    g_display_state.hour = 0;
    g_display_state.minute = 0;
    g_display_state.battery_percent = 0;
    g_display_state.last_update_ms = 0;
    g_display_state.last_time_check_ms = 0;
    g_display_state.last_battery_check_ms = 0;

    Serial.println("Display: Initialized state tracking");
}

bool displayNeedsUpdate(float current_water_ml,
                       uint16_t current_daily_ml,
                       bool time_interval_elapsed,
                       bool battery_interval_elapsed) {
    bool needs_update = false;

    // 1. Water level check (5ml threshold)
    if (!g_display_state.initialized ||
        fabs(current_water_ml - g_display_state.water_ml) >= DISPLAY_UPDATE_THRESHOLD_ML) {
        DEBUG_PRINTF(1, "Display: Water level changed (%.1fml -> %.1fml)\n",
                     g_display_state.water_ml, current_water_ml);
        needs_update = true;
    }

    // 2. Daily intake check (50ml threshold)
    if (abs((int)current_daily_ml - (int)g_display_state.daily_total_ml) >=
        DRINK_DISPLAY_UPDATE_THRESHOLD_ML) {
        DEBUG_PRINTF(1, "Display: Daily intake changed (%dml -> %dml)\n",
                     g_display_state.daily_total_ml, current_daily_ml);
        needs_update = true;
    }

    // 3. Time check (always check if time is valid, update if hour changed or 15+ min elapsed)
    if (g_time_valid) {
        struct timeval tv;
        gettimeofday(&tv, NULL);
        time_t now = tv.tv_sec + (g_timezone_offset * 3600);
        struct tm timeinfo;
        gmtime_r(&now, &timeinfo);

        // Update if: hour changed OR 15+ minutes elapsed since last check
        if (timeinfo.tm_hour != g_display_state.hour ||
            (time_interval_elapsed && abs(timeinfo.tm_min - (int)g_display_state.minute) >= DISPLAY_TIME_UPDATE_THRESHOLD_MIN)) {
            DEBUG_PRINTF(1, "Display: Time changed (%d:%02d -> %d:%02d)\n",
                         g_display_state.hour, g_display_state.minute,
                         timeinfo.tm_hour, timeinfo.tm_min);
            needs_update = true;
        }
    }

    // 4. Battery check (if interval elapsed)
#if defined(BOARD_ADAFRUIT_FEATHER)
    if (battery_interval_elapsed) {
        float voltage = getBatteryVoltage();
        int raw_percent = getBatteryPercent(voltage);
        uint8_t quantized = quantizeBatteryPercent(raw_percent);

        if (abs((int)quantized - (int)g_display_state.battery_percent) >=
            DISPLAY_BATTERY_UPDATE_THRESHOLD) {
            DEBUG_PRINTF(1, "Display: Battery changed (%d%% -> %d%%)\n",
                         g_display_state.battery_percent, quantized);
            needs_update = true;
        }
    }
#endif

    return needs_update;
}

void displayUpdate(float water_ml, uint16_t daily_total_ml) {
    if (g_display_ptr == nullptr) {
        Serial.println("Display ERROR: Not initialized!");
        return;
    }

    DEBUG_PRINTF(1, "Display: Updating screen (water=%.1fml, daily=%dml)\n",
                 water_ml, daily_total_ml);

    // Update display state BEFORE rendering
    g_display_state.water_ml = water_ml;
    g_display_state.daily_total_ml = daily_total_ml;
    g_display_state.last_update_ms = millis();

    // Update time state
    if (g_time_valid) {
        struct timeval tv;
        gettimeofday(&tv, NULL);
        time_t now = tv.tv_sec + (g_timezone_offset * 3600);
        struct tm timeinfo;
        gmtime_r(&now, &timeinfo);
        g_display_state.hour = timeinfo.tm_hour;
        g_display_state.minute = timeinfo.tm_min;
    }

    // Update battery state
#if defined(BOARD_ADAFRUIT_FEATHER)
    float voltage = getBatteryVoltage();
    int raw_percent = getBatteryPercent(voltage);
    g_display_state.battery_percent = quantizeBatteryPercent(raw_percent);
#endif

    g_display_state.initialized = true;

    // Render the main screen
    drawMainScreen();
}

void displayForceUpdate() {
    DEBUG_PRINTF(1, "Display: Force update triggered\n");
    g_display_state.initialized = false;

    // Get current values and update
    float water_ml = 0.0f;
    if (g_calibrated && nauReady && nau.available()) {
        int32_t current_adc = nau.read();
        water_ml = calibrationGetWaterWeight(current_adc, g_calibration);
        if (water_ml < 0) water_ml = 0;
        if (water_ml > 830) water_ml = 830;
    }

    DailyState daily_state;
    drinksGetState(daily_state);
    displayUpdate(water_ml, daily_state.daily_total_ml);
}

#if defined(BOARD_ADAFRUIT_FEATHER)
void drawMainScreen() {
    if (g_display_ptr == nullptr) return;

    Serial.println("Drawing main screen...");
    g_display_ptr->clearBuffer();
    g_display_ptr->setTextColor(EPD_BLACK);

    // Get current water level
    float water_ml = g_display_state.water_ml;
    if (water_ml < 0) water_ml = 0;  // Default if not initialized

    // Draw vertical bottle graphic on left side
    int bottle_x = 10;
    int bottle_y = 20;
    float fill_percent = water_ml / 830.0f;
    drawBottleGraphic(bottle_x, bottle_y, fill_percent);

    // Draw large text showing daily intake (center)
    g_display_ptr->setTextSize(3);
    char intake_text[16];
    snprintf(intake_text, sizeof(intake_text), "%dml", g_display_state.daily_total_ml);

    int intake_text_width = strlen(intake_text) * 18;
    int available_width = 185 - 60;
    int intake_x = 60 + (available_width - intake_text_width) / 2;

    g_display_ptr->setCursor(intake_x, 50);
    g_display_ptr->print(intake_text);

    // Draw "today" label below
    g_display_ptr->setTextSize(2);
    int today_width = 5 * 12;
    int today_x = 60 + (available_width - today_width) / 2;
    g_display_ptr->setCursor(today_x, 75);
    g_display_ptr->print("today");

    // Draw battery status in top-right corner
    drawBatteryIcon(220, 5, g_display_state.battery_percent);

    // Draw time centered at top
    char time_text[16];
    formatTimeForDisplay(time_text, sizeof(time_text));
    g_display_ptr->setTextSize(1);

    int text_width = strlen(time_text) * 6;
    int center_x = (250 - text_width) / 2;
    g_display_ptr->setCursor(center_x, 5);
    g_display_ptr->print(time_text);

    // Draw daily intake visualization (if time is valid)
    float daily_fill = 0.0f;
    if (g_time_valid) {
        daily_fill = (float)g_display_state.daily_total_ml / (float)DRINK_DAILY_GOAL_ML;
        if (daily_fill > 1.0f) daily_fill = 1.0f;
    }

    #if DAILY_INTAKE_DISPLAY_MODE == 0
        int figure_x = 185;
        int figure_y = 20;
        drawHumanFigure(figure_x, figure_y, daily_fill);
    #else
        int grid_x = 195;
        int grid_y = 20;
        drawGlassGrid(grid_x, grid_y, daily_fill);
    #endif

    g_display_ptr->display();
}
#endif
